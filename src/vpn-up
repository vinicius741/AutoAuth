#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const os = require('os');
const { execSync, spawn } = require('child_process');
const { authenticator } = require('otplib');

// Load environment variables from .env file (if it exists)
require('dotenv').config({ path: path.join(__dirname, '..', '.env') });

// Configuration
const HOME = os.homedir();
const PIDFILE = path.join(HOME, '.vpn.pid');
const LOGFILE = path.join(HOME, '.vpn.log');
const AUTHFILE = path.join(HOME, '.vpn.auth');

// Helper to run shell commands
const run = (cmd) => {
    try {
        return execSync(cmd, { stdio: 'pipe', encoding: 'utf-8' }).trim();
    } catch (error) {
        throw new Error(`Command failed: ${cmd}\n${error.stderr || error.message}`);
    }
};

// Main function
const main = async () => {
    // Check if VPN is already connected
    if (fs.existsSync(PIDFILE)) {
        const pid = fs.readFileSync(PIDFILE, 'utf-8').trim();
        try {
            // Check if process exists. 'kill -0' is a standard way to check existence without killing.
            process.kill(pid, 0); 
            console.error(`VPN is already connected (PID: ${pid})`);
            process.exit(1);
        } catch (e) {
            // Process doesn't exist, stale PID file
            try { fs.unlinkSync(PIDFILE); } catch (err) {}
        }
    }

    // Determine config path
    let vpnConfig = process.argv[2] || process.env.VPN_CONFIG;
    const vpnUser = process.env.VPN_USER || process.env.USER || run('whoami');

    if (!vpnConfig) {
        console.error('Error: VPN config path not set.');
        console.error('Set VPN_CONFIG in .env file, environment variable, or pass config path as argument:');
        console.error(`  1. Create .env file in project root: VPN_CONFIG=/path/to/config.ovpn`);
        console.error(`  2. Export var: export VPN_CONFIG=$HOME/path/to/config.ovpn`);
        console.error(`  3. Pass arg: ${path.basename(process.argv[1])} /path/to/config.ovpn`);
        process.exit(1);
    }

    // Resolve absolute path
    vpnConfig = path.resolve(process.cwd(), vpnConfig);

    if (!fs.existsSync(vpnConfig)) {
        console.error(`Error: VPN config file not found: ${vpnConfig}`);
        process.exit(1);
    }

    // Check dependencies
    try {
        execSync('command -v openvpn');
    } catch (e) {
        console.error('Error: openvpn not found. Install with: brew install openvpn');
        process.exit(1);
    }
    
    // Retrieve secrets from Keychain
    console.error('Retrieving credentials from Keychain...');
    
    const currentUser = process.env.USER || run('whoami');

    let pin, totpSecret;
    try {
        pin = run(`security find-generic-password -a "${currentUser}" -s "vpn_pin" -w`);
    } catch (e) {
        console.error('Error: Failed to retrieve PIN from Keychain. Run:');
        console.error(`  security add-generic-password -a "${currentUser}" -s "vpn_pin" -w`);
        process.exit(1);
    }

    try {
        totpSecret = run(`security find-generic-password -a "${currentUser}" -s "vpn_totp_secret" -w`);
    } catch (e) {
        console.error('Error: Failed to retrieve TOTP secret from Keychain. Run:');
        console.error(`  security add-generic-password -a "${currentUser}" -s "vpn_totp_secret" -w`);
        process.exit(1);
    }

    // Generate TOTP code
    let totp;
    try {
        totp = authenticator.generate(totpSecret);
    } catch (e) {
        console.error('Error: Failed to generate TOTP code. Check that your TOTP secret is valid base32.');
        process.exit(1);
    }

    const password = `${pin}${totp}`;

    // Create temporary auth file
    try {
        const authContent = `${vpnUser}\n${password}`;
        fs.writeFileSync(AUTHFILE, authContent, { mode: 0o600 });
    } catch (e) {
        console.error(`Error writing auth file: ${e.message}`);
        process.exit(1);
    }

    // Cleanup logic
    const cleanup = () => {
        try {
            if (fs.existsSync(AUTHFILE)) {
                fs.unlinkSync(AUTHFILE);
            }
        } catch (err) {
            // ignore cleanup errors
        }
    };

    // Start OpenVPN
    console.error('Starting OpenVPN...');
    
    // Construct command
    const openVpnCmd = `openvpn --config "${vpnConfig}" --auth-user-pass "${AUTHFILE}" --daemon --writepid "${PIDFILE}" --log "${LOGFILE}" --auth-nocache`;
    
    try {
        execSync(openVpnCmd, { stdio: 'inherit' });
    } catch (e) {
        console.error(`Error starting OpenVPN: ${e.message}`);
        cleanup(); // Cleanup on immediate failure
        process.exit(1);
    }

    console.error('VPN process initiated. Monitoring logs for connection status...');

    const tail = spawn('tail', ['-f', LOGFILE]);
    
    // Timeout after 30 seconds
    const timeout = setTimeout(() => {
        console.error('Error: Connection timed out (30s).');
        tail.kill();
        cleanup();
        // Try to kill the vpn process if it exists
        if (fs.existsSync(PIDFILE)) {
             try { 
                 const pid = fs.readFileSync(PIDFILE, 'utf-8').trim();
                 process.kill(pid, 'SIGTERM'); 
             } catch(e){}
        }
        process.exit(1);
    }, 30000);

    tail.stdout.on('data', (data) => {
        const output = data.toString();
        
        if (output.includes('Initialization Sequence Completed')) {
            console.error('✅ VPN Connected Successfully!');
            clearTimeout(timeout);
            tail.kill();
            cleanup(); // Securely remove auth file
            process.exit(0);
        }

        if (output.includes('AUTH_FAILED') || output.includes('process exiting') || output.includes('Exiting due to fatal error')) {
            console.error('❌ VPN Connection Failed (Authentication Failure or Error).');
            console.error(`Check logs for details: ${LOGFILE}`);
            clearTimeout(timeout);
            tail.kill();
            cleanup();
            process.exit(1);
        }
    });
};

main();